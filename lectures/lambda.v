Require Import Coq.Strings.String Coq.Init.Nat Lia.


(** * Pure Lambda Calculus **)


(** 

  The lambda calculus (λ-calculus) is an abstract model of computation
  introduced by Alonzo Church in the 1930s.

  TODO something about foundations of math

  As a model of computation, lambda calculus is Turing-complete
  (Turing, 1937).

  Functional programming languages evolved from the lambda
  calculus. The lambda calculus is a tiny functional programming
  language that we will use to study the semantics and formal
  properties of functional programming languages.

  Lambda calculus is a formal language that consists of

  - functions (or "abstractions"), written as "λx. e" where "x" is a
    variable _bound_ in the body of the function "e"

    A more familiar syntax for functions is ML's "fun x -> e"

  - function applications, written "e1 e1"

  - Variables. To denote variables we use strings.

  For example, we can write the application of the identity function
  to the identity function: "(λx. x) (λx. x)"

  Lambda calculus in generated by the following grammar (in BNF form):

  term := λvar. term | term term | var

  with var ∈ {x, y, z, ... }

  We start by defining the abstract syntax tree of lambda calculus in
  Coq.

*)

(** ** Pure Lambda Calculus: Syntax **)

(** The abstract syntax tree of lambda calculus. *)
Inductive term : Type := 
| App : term -> term -> term 
| Lambda : string -> term -> term
| Var : string -> term.


Definition id : term := Lambda "x" (Var "x").

Definition app_id_id : term := App id id. 

Print id.

Print app_id_id.


(** To make our lives slightly easier, let's define some concrete syntax for
    lambda terms, using Coq's notations. *)

Declare Custom Entry LC.

Notation "<{ e }>" := e (e custom LC at level 99).
Notation "( x )" := x (in custom LC, x at level 99).
Notation "x" := x (in custom LC at level 0, x constr at level 0).
Notation "x y" := (App x y) (in custom LC at level 1, left associativity).
Notation "\ x , y" := (Lambda x y) (in custom LC at level 90,
                            x at level 99,
                            y custom LC at level 99,
                            left associativity).

(** Let's also define an implicit coercion to avoid writing to many "Var"s *)

Coercion Var : string >-> term.

Definition x : string := "x".
Definition y : string := "y".
Definition z : string := "z".

Definition id_pretty : term := <{ \ x, x }>. 

Definition app_id_pretty : term := <{ id id }>. 


(** ** Pure Lambda Calculus: Semantics **)

(** *** Lexical Scoping *)

(** *** Free and Bound Variables *)


(** *** Alpha Equivalence *)

(** *** Substitution *)

(** A very common notation from substution in mathematical text is

    t[t'/x]

    Which means "substitute all _free_ occurences of x in t with t' "

 *)

(** TODO capture avoiding substitution *)

Fixpoint subst (x : string) (t' : term) (t : term) : term :=
  match t with
  | App t1 t2 => App (subst x t' t1) (subst x t' t2)
  | Lambda y t1 => if (x =? y)%string then Lambda y t1 else Lambda y (subst x t' t1)
  | Var y => if (x =? y)%string then t' else Var y
  end.

(* Fixpoint subst (x : string) (t' : term) (t : term) : option term := *)
(*   match t with *)
(*   | App t1 t2 => *)
(*       App (subst x t' t1) (subst x t' t2) *)
(*   | Lambda y t1 => if (x =? y)%string then Lambda y t1 else Lambda y (subst x t' t1) *)
(*   | Var y => if (x =? y)%string then t' else Var y *)
(*   end. *)

Notation "'[' x ':=' s ']' t" := (subst x s t) (in custom LC at level 20, x constr).


Inductive multi {A} (R : A -> A -> Prop) : A -> A -> Prop :=
  | multi_refl : forall a, multi R a a
  | multi_step : forall a b c,
    R a b ->
    multi R b c -> 
    multi R a c.


(** *** Full Beta Reduction *)

Module Full.
  
  Reserved Notation "t '-->' t'" (at level 40).

  Inductive step : term -> term -> Prop :=
  | step_abs : forall x t1 v2, 
      <{ (\x, t1) v2 }> --> <{ [x:=v2]t1 }>
  | step_app1 : forall t1 t1' t2,
      t1 --> t1' ->
      <{ t1 t2 }> --> <{ t1' t2 }>
  | step_app2 : forall v1 t2 t2',
      t2 --> t2' ->
      <{ v1 t2 }> --> <{ v1 t2' }>

  where "t '-->' t'" := (step t t').

  Notation multistep := (multi step).
  Notation "t1 '-->*' t2" := (multistep t1 t2) (at level 40).

  (* TODO redex *)
  
End Full.

(** **** Confluence *)

(** *** Values **)

Definition value (t : term) : bool :=
  match t with
  | Lambda _ _ => true
  | _ => false
  end.


(** *** Call by Value *)

Module CBV.

  Reserved Notation "t '-->' t'" (at level 40).
    
  Inductive step : term -> term -> Prop :=
  | step_abs : forall x t1 v2,
      value v2 = true -> 
      <{ (\x, t1) v2 }> --> <{ [x:=v2]t1 }>
  | step_app1 : forall t1 t1' t2,
      t1 --> t1' ->
      <{ t1 t2 }> --> <{ t1' t2 }>
  | step_app2 : forall v1 t2 t2',
      value v1 = true -> 
      t2 --> t2' ->
      <{ v1 t2 }> --> <{ v1 t2' }>
        
  where "t '-->' t'" := (step t t').

  Notation multistep := (multi step).

  Notation "t1 '-->*' t2" := (multistep t1 t2) (at level 40).

End CBV.


(** *** Call by Name *)

Module CBN.

  Reserved Notation "t '-->' t'" (at level 40).
  
  Inductive step : term -> term -> Prop :=
  | step_abs : forall x t1 t2,
      <{ (\x, t1) t2 }> --> <{ [x:=t2]t1 }>
  | step_app1 : forall t1 t1' t2,
      t1 --> t1' ->
      <{ t1 t2 }> --> <{ t1' t2 }>
  | step_app2 : forall v1 t2 t2',
      value v1 = true -> 
      t2 --> t2' ->
      <{ v1 t2 }> --> <{ v1 t2' }>
        
  where "t '-->' t'" := (step t t').

  Notation multistep := (multi step).

  Notation "t1 '-->*' t2" := (multistep t1 t2) (at level 40).

End CBN.

(** TODO note about call by need *)

(** *** Stuck States *)


(** **** Confluence *)


(** [multi] is the reflexive transitive closure of [R].

    Or, equivalenty, the smallest relation that contains R and is closed under
    reflexivity and transitivity.
 
**)    

Import CBV.

(** ** Big-step semantics **)

Reserved Notation "t '==>' t'" (at level 40).

Inductive bigstep : term -> term -> Prop :=
| bigstep_abs : forall x t1, 
      <{ \x, t1 }> ==> <{ \x, t1 }>
| bigstep_app : forall t1 x t1' t2 v2 v,
    t1 ==> <{ \x, t1' }> ->
    t2 ==> v2 ->
    <{ [x:=v2]t1' }> ==> v ->
    <{ t1 t2 }> ==> v

where "t '==>' t'" := (bigstep t t').

Lemma bigstep_value :
  forall t1 t2, t1 ==> t2 -> value t2 = true.
Proof.
  intros t1 t2 Hyp. induction Hyp.
  - simpl. reflexivity.
  - assumption.
Qed.

Lemma value_bigstep :
  forall v,
    value v = true -> 
    v ==> v.
Proof.
  intros v Hv. destruct v; simpl in *.
  - congruence.
  - apply bigstep_abs.
  - congruence.
Qed.

(** *** Case study: Small-step bigstep equivalence *)

    
Lemma multi_step_compose1 :
  forall t1 t2 t1',
    t1 -->* t1' ->
    <{ t1 t2 }> -->* <{ t1' t2 }>.
Proof.
  intros t1 t2 t1' H1.
  induction H1.
  - apply multi_refl.
  - eapply multi_step. 
    + eapply step_app1. eassumption. 
    + assumption.
Qed.

Lemma multi_step_compose2 :
  forall t1 t2 t2',
    t2 -->* t2' ->
    value t1 = true -> 
    <{ t1 t2 }> -->* <{ t1 t2' }>.
Proof.
  intros t1 t2 t2' H1 Hval.
  induction H1.
  - apply multi_refl.
  - eapply multi_step. 
    + eapply step_app2. assumption. eassumption.
    + assumption.
Qed.

Lemma multi_trans {A} (R : A -> A -> Prop) :
  forall a b c,
    multi R a b ->
    multi R b c ->
    multi R a c.
Proof.
  intros a b c H1 H2.
  induction H1. 
  - assumption.
  - eapply multi_step. eassumption.
    eapply IHmulti. assumption.
Qed. 

Lemma bigstep_step :
  forall t1 t2,
    t1 ==> t2 -> t1 -->* t2.
Proof.
  intros t1 t2 Hyp. induction Hyp.
  - apply multi_refl.
  - eapply multi_trans.
    + eapply multi_step_compose1. eassumption.      
    + eapply multi_trans.
      * eapply multi_step_compose2. eassumption.      
        reflexivity.
      * eapply multi_step.
        -- eapply step_abs.
           eapply bigstep_value. eassumption.
        -- assumption.
Qed.

Lemma step_bigstep_compose :
  forall t1 t2 t3,
    t1 --> t2 -> t2 ==> t3 -> t1 ==> t3.
Proof.
    intros t1 t2 t3 Hstep. revert t3. induction Hstep; intros t3 Hbstep.
    - eapply bigstep_app.
      + eapply bigstep_abs.
      + eapply value_bigstep. assumption.
      + assumption.
    - inversion Hbstep; subst.
      eapply IHHstep in H1.
      eapply bigstep_app; eassumption.
    - inversion Hbstep; subst.
      eapply IHHstep in H3.
      eapply bigstep_app; eassumption.
Qed.    

Lemma step_bigstep :
  forall t1 t2,
    t1 -->* t2 -> value t2 = true -> t1 ==> t2.
Proof.
    intros t1 t2 Hyp Hval. induction Hyp.
    - destruct a; simpl in *.
      + congruence.
      + apply bigstep_abs.
      + congruence.
    - eapply step_bigstep_compose. eassumption.
      eauto.
Qed.



(** *** Interpreter *)

Fixpoint eval (fuel : nat) (t : term) : option term :=
  match fuel with
  | 0 => None
  | S fuel' =>
      match t with
      | <{ t1 t2 }> =>
          match eval fuel' t1 with
          | Some <{ \ x, t }> =>
              match eval fuel' t2 with
              | Some v => eval fuel' (<{ [x := v] t }>)
              | None => None
              end
          | _ => None 
          end
      | <{ \x, t }> => Some <{ \x, t }>
      | Var x => Some (Var x)
      end
  end. 
  

(** *** Turing Completeness *)

(**
-- Lambda terms an encode a Turing machine 
-- The functions definable in lambda calculus are exaclty the recursive functions

*)

(** *** Church Numerals *)

(** http://lambdacalc.io *) 

(** *** Recursion: The Y Combinator *)


Definition f : string := "f".

Definition Y :=
  <{ \f, (\x, f (x x)) (\x, f (x x)) }>.


(** *** From Lambda Calculus to a (Untyped) Mini ML *)

Module MiniML.

  
  Inductive bop :=
  | Plus | Minus | Mult
  | And | Or | Lt | Eq.

  Inductive uop :=
  | Neg.

  (** The abstract syntax tree of lambda calculus. *)
  Inductive term : Type := 
  (* Functions *)
  | T_App : term -> term -> term 
  | T_Lambda : string -> term -> term
  (* Variables *)
  | T_Var : string -> term
  (* Natural Numbers *)
  | T_Nat : nat -> term
  (* Booleans *)
  | T_Bool : bool -> term
  (* Binary Operators *)
  | T_BOp : bop -> term -> term -> term
  (* Unary Operatos *)
  | T_UOp : uop -> term -> term
  (* Pairs *)              
  | T_Pair : term -> term -> term
  | T_Fst : term -> term
  | T_Snd : term -> term
  (* Let *)
  | T_Let : string -> term -> term -> term
  (* If *)
  | T_If : term -> term -> term -> term
  .

  Declare Custom Entry ML.
  Declare Scope ML_scope.

  
  Notation "<[ e ]>" := e (e custom ML at level 99) : ML_scope.
  Notation "( x )" := x (in custom ML, x at level 99).
  Notation "x" := x (in custom ML at level 0, x constr at level 0).
  Notation "x y" := (T_App x y) (in custom ML at level 1, left associativity).

  Notation "'fun' x '->' y" := (T_Lambda x y) (in custom ML at level 90,
                                     x at level 99,
                                     y custom ML at level 99,
                                     left associativity) : ML_scope.

  Notation "'let' x ':=' y 'in' z" := (T_Let x y z) (in custom ML at level 90,
                                         x at level 99,
                                         y custom ML at level 100,
                                         z custom ML at level 100, left associativity) : ML_scope.

  Notation "'if' x 'then' y 'else' z" :=
    (T_If x y z)
      (in custom ML at level 89, x at level 99,
          y at level 99, z at level 99) : ML_scope.

  Notation "'true'" := true (at level 1).
  Notation "'true'" := (T_Bool true) (in custom ML at level 0).
  Notation "'false'" := false (at level 1).
  Notation "'false'" :=  (T_Bool false) (in custom ML at level 0).

  Notation "x <= y" := (T_BOp Or (T_BOp Lt x y) (T_BOp Eq x y))
                         (in custom ML at level 70, no associativity) : ML_scope.
  Notation "x < y" := (T_BOp Lt x y)
                        (in custom ML at level 70, no associativity) : ML_scope.
  Notation "x = y" := (T_BOp Eq x y)
                        (in custom ML at level 70, no associativity) : ML_scope.
  
  Notation "x <> y" := (T_UOp Neg (T_BOp Eq x y))
                         (in custom ML at level 70, no associativity) : ML_scope.
  
  Notation "x && y" := (T_BOp And x y) (in custom ML at level 80, left associativity) : ML_scope.
  Notation "x || y" := (T_BOp Or x y) (in custom ML at level 80, left associativity) : ML_scope.
  
  Notation "'~' b" := (T_UOp Neg b) (in custom ML at level 75, right associativity) : ML_scope.

  Notation "x + y" := (T_BOp Plus x y) (in custom ML at level 50, left associativity) : ML_scope.
  Notation "x - y" := (T_BOp Minus x y) (in custom ML at level 50, left associativity) : ML_scope.
  Notation "x * y" := (T_BOp Mult x y) (in custom ML at level 40, left associativity) : ML_scope.


  Coercion T_Var : string >-> term.
  Coercion T_Nat : nat >-> term.
  
  Open Scope ML_scope.

  Unset Printing Notations.

  Definition foo : string := "foo". 
  Definition bar : string := "bar".
  

  Definition test := <[ let foo := (fun x -> x + 4) in
                        let bar := (fun x -> x + 5) in
                        (foo 4) ]>.

  
  Definition Y := <[ fun f -> (fun x -> f (x x)) (fun x -> f (x x)) ]>.

  Definition Z := <[ fun f -> (fun x -> f (fun y -> x x y)) (fun x -> f (fun y -> x x y)) ]>.
(* (T_Lambda f (T_App (T_Lambda x (T_App f (T_App x x))) (T_Lambda x (T_App f (T_App x x))))) *)

  Notation "'letrec' f ':=' y 'in' z" :=
    (T_Let f (T_App Z (T_Lambda f y)) z)
      (in custom ML at level 90,
          f at level 99,
          y custom ML at level 99,
          z custom ML at level 99) : ML_scope.

  Definition fact : string := "fact".
  Definition n : string := "n".
  
  (** *** Interpreter *)

  Fixpoint subst (x : string) (t' : term) (t : term) : term :=
    match t with
    | T_App t1 t2 => T_App (subst x t' t1) (subst x t' t2)
    | T_Lambda y t1 => if (x =? y)%string then T_Lambda y t1 else T_Lambda y (subst x t' t1)
    | T_Var y => if (x =? y)%string then t' else T_Var y
    | T_BOp op t1 t2 => T_BOp op (subst x t' t1) (subst x t' t2)
    | T_UOp op t => T_UOp op (subst x t' t)
    | T_Pair t1 t2 => T_Pair (subst x t' t1) (subst x t' t2)
    | T_Fst t => T_Fst (subst x t' t)
    | T_Snd t => T_Snd (subst x t' t)
    | T_Let y t1 t2 =>
        T_Let y  (subst x t' t1) (if (x =? y)%string then t1 else subst x t' t2)
    | T_If t1 t2 t3 =>
        T_If (subst x t' t1) (subst x t' t2) (subst x t' t3)
    | t => t             
    end. 

  
  Notation "'[' x ':=' s ']' t" := (subst x s t) (in custom ML at level 20, x constr).


  Fixpoint eval (fuel : nat) (t : term) : option term :=
    match fuel with
    | 0 => None
    | S fuel' =>
        match t with
        (* Application *)
        | <[ t1 t2 ]> =>
            match eval fuel' t1 with
            | Some <[ fun x -> t ]> => 
                match eval fuel' t2 with
                | Some v => eval fuel' (subst x v t)
                | None => None
                end
            | _ => None 
            end
        (* Let *)
        | <[ let x := t1 in t2]> => (* eval fuel' <[ (fun x -> t2) t1 ]> *)
            match eval fuel' t1 with
            | Some v => eval fuel' (subst x v t2)
            | None => None
            end
        (* If *)
        | <[ if t1 then t2 else t3 ]> =>
            match eval fuel' t1 with
            | Some (T_Bool true) => eval fuel' t2
            | Some (T_Bool false) => eval fuel' t3
            | _ => None
            end
        (* Bop *)
        | T_BOp bop t1 t2 =>
            match eval fuel' t1, eval fuel' t2 with
            | Some (T_Bool b1), Some (T_Bool b2) =>
                match bop with
                | And => Some (T_Bool (b1 && b2))
                | Or => Some (T_Bool (b1 || b2))
                | _ => None
                end
            | Some (T_Nat n1), Some (T_Nat n2) =>
               match bop with
               | Plus => Some (T_Nat (n1 + n2))
               | Minus => Some (T_Nat (n1 - n2))
               | Mult => Some (T_Nat (n1 * n2))
               | Lt => Some (T_Bool (n1 <? n2))
               | Eq => Some (T_Bool (n1 =? n2))
               | _ => None
               end 
            | _, _ => None
            end
        (* Uop *)
        | T_UOp op t =>
            match eval fuel' t with
            | Some (T_Bool b) =>
                match op with
                | Neg => Some (T_Bool (negb b))
                end
            | _ => None
            end
        (* Fst *)
        | T_Fst t =>
            match eval fuel' t with
            | Some (T_Pair t1 _) => Some t1
            | _ => None
            end
        (* Snd *)
        | T_Snd t =>
            match eval fuel' t with
            | Some (T_Pair _ t2) => Some t2
            | _ => None
            end
        (* Pair *)
        | T_Pair t1 t2 =>
            match eval fuel' t1, eval fuel' t2 with
            | Some v1, Some v2 => Some (T_Pair v1 v2)
            | _, _ => None
            end
        (* Values*)
        | <[ fun x -> t ]> => Some <[ fun x -> t ]>
        | T_Nat n => Some (T_Nat n)
        | T_Bool b => Some (T_Bool b)
        | T_Var x => Some (T_Var x)
        end
    end.
  
  Compute (eval 1000 <[ let f := (fun x -> x + 4) in f 4 ]>).

  Definition myfact : term :=
    <[ letrec fact := fun n -> if n = 0 then 0 else n * fact (n - 1) in fact 5 ]>.

  Definition test' := <[ let foo := (fun x -> x + 4) in
                        let bar := (fun x -> x) in
                        (foo 4) ]>.

  Definition test'' : term :=
    <[ let fact := fun n -> if n = 0 then 0 else n * n in fact 5 ]>.
 
  Compute (eval 1000 test''). 

  Compute (eval 1000 myfact).
  
  Definition d : string := "d".

  Definition myrec : term :=
    <[ let foo := Z (fun d -> (fun n -> if n = 0 then 0 else 2 + d (n - 1))) in foo 5 ]>.

  Compute (eval 1000000 myrec).
    
  (* TODO fix *)
  Compute (eval 1000 <[ let foo := (fun x -> x + 4) in
                        let bar := (fun y -> y + 1) in
                        (foo (bar 4)) ]>).

